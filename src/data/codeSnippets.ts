import type { CodeSnippet } from '../types';

export const codeSnippets: CodeSnippet[] = [
  {
    language: 'typescript',
    title: 'Binary Search',
    lines: [
      'function binarySearch<T>(arr: T[], target: T): number {',
      '  let left = 0;',
      '  let right = arr.length - 1;',
      '',
      '  while (left <= right) {',
      '    const mid = Math.floor((left + right) / 2);',
      '    ',
      '    if (arr[mid] === target) {',
      '      return mid;',
      '    }',
      '    ',
      '    if (arr[mid] < target) {',
      '      left = mid + 1;',
      '    } else {',
      '      right = mid - 1;',
      '    }',
      '  }',
      '  ',
      '  return -1;',
      '}',
    ],
  },
  {
    language: 'python',
    title: 'Quick Sort',
    lines: [
      'def quicksort(arr):',
      '    if len(arr) <= 1:',
      '        return arr',
      '    ',
      '    pivot = arr[len(arr) // 2]',
      '    left = [x for x in arr if x < pivot]',
      '    middle = [x for x in arr if x == pivot]',
      '    right = [x for x in arr if x > pivot]',
      '    ',
      '    return quicksort(left) + middle + quicksort(right)',
    ],
  },
  {
    language: 'rust',
    title: 'Fibonacci with Memoization',
    lines: [
      'use std::collections::HashMap;',
      '',
      'fn fibonacci(n: u64, memo: &mut HashMap<u64, u64>) -> u64 {',
      '    if n <= 1 {',
      '        return n;',
      '    }',
      '    ',
      '    if let Some(&result) = memo.get(&n) {',
      '        return result;',
      '    }',
      '    ',
      '    let result = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);',
      '    memo.insert(n, result);',
      '    result',
      '}',
    ],
  },
  {
    language: 'javascript',
    title: 'Debounce Function',
    lines: [
      'function debounce(func, wait) {',
      '  let timeout;',
      '  ',
      '  return function executedFunction(...args) {',
      '    const later = () => {',
      '      clearTimeout(timeout);',
      '      func(...args);',
      '    };',
      '    ',
      '    clearTimeout(timeout);',
      '    timeout = setTimeout(later, wait);',
      '  };',
      '}',
    ],
  },
  {
    language: 'go',
    title: 'Concurrent Worker Pool',
    lines: [
      'func workerPool(jobs <-chan int, results chan<- int) {',
      '    for j := range jobs {',
      '        results <- process(j)',
      '    }',
      '}',
      '',
      'func main() {',
      '    jobs := make(chan int, 100)',
      '    results := make(chan int, 100)',
      '    ',
      '    for w := 1; w <= 3; w++ {',
      '        go workerPool(jobs, results)',
      '    }',
      '    ',
      '    for j := 1; j <= 9; j++ {',
      '        jobs <- j',
      '    }',
      '    close(jobs)',
      '}',
    ],
  },
  {
    language: 'typescript',
    title: 'Event Emitter',
    lines: [
      'class EventEmitter {',
      '  private events: Map<string, Function[]> = new Map();',
      '',
      '  on(event: string, listener: Function) {',
      '    if (!this.events.has(event)) {',
      '      this.events.set(event, []);',
      '    }',
      '    this.events.get(event)!.push(listener);',
      '  }',
      '',
      '  emit(event: string, ...args: any[]) {',
      '    const listeners = this.events.get(event);',
      '    if (listeners) {',
      '      listeners.forEach(listener => listener(...args));',
      '    }',
      '  }',
      '',
      '  off(event: string, listener: Function) {',
      '    const listeners = this.events.get(event);',
      '    if (listeners) {',
      '      const index = listeners.indexOf(listener);',
      '      if (index > -1) listeners.splice(index, 1);',
      '    }',
      '  }',
      '}',
    ],
  },
  {
    language: 'python',
    title: 'LRU Cache',
    lines: [
      'from collections import OrderedDict',
      '',
      'class LRUCache:',
      '    def __init__(self, capacity: int):',
      '        self.cache = OrderedDict()',
      '        self.capacity = capacity',
      '',
      '    def get(self, key: int) -> int:',
      '        if key not in self.cache:',
      '            return -1',
      '        self.cache.move_to_end(key)',
      '        return self.cache[key]',
      '',
      '    def put(self, key: int, value: int) -> None:',
      '        if key in self.cache:',
      '            self.cache.move_to_end(key)',
      '        self.cache[key] = value',
      '        if len(self.cache) > self.capacity:',
      '            self.cache.popitem(last=False)',
    ],
  },
  {
    language: 'rust',
    title: 'Result Error Handling',
    lines: [
      'use std::fs::File;',
      'use std::io::{self, Read};',
      '',
      'fn read_file_contents(path: &str) -> Result<String, io::Error> {',
      '    let mut file = File::open(path)?;',
      '    let mut contents = String::new();',
      '    file.read_to_string(&mut contents)?;',
      '    Ok(contents)',
      '}',
      '',
      'fn main() {',
      '    match read_file_contents("config.txt") {',
      '        Ok(contents) => println!("{}", contents),',
      '        Err(e) => eprintln!("Error: {}", e),',
      '    }',
      '}',
    ],
  },
  {
    language: 'javascript',
    title: 'Promise.all Implementation',
    lines: [
      'function promiseAll(promises) {',
      '  return new Promise((resolve, reject) => {',
      '    const results = [];',
      '    let completed = 0;',
      '    ',
      '    if (promises.length === 0) {',
      '      resolve(results);',
      '      return;',
      '    }',
      '    ',
      '    promises.forEach((promise, index) => {',
      '      Promise.resolve(promise)',
      '        .then(value => {',
      '          results[index] = value;',
      '          completed++;',
      '          if (completed === promises.length) {',
      '            resolve(results);',
      '          }',
      '        })',
      '        .catch(reject);',
      '    });',
      '  });',
      '}',
    ],
  },
  {
    language: 'go',
    title: 'HTTP Middleware',
    lines: [
      'func loggingMiddleware(next http.Handler) http.Handler {',
      '    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {',
      '        start := time.Now()',
      '        ',
      '        next.ServeHTTP(w, r)',
      '        ',
      '        log.Printf(',
      '            "%s %s %s",',
      '            r.Method,',
      '            r.RequestURI,',
      '            time.Since(start),',
      '        )',
      '    })',
      '}',
    ],
  },
  {
    language: 'typescript',
    title: 'State Machine',
    lines: [
      'type State = "idle" | "loading" | "success" | "error";',
      '',
      'interface StateMachine {',
      '  state: State;',
      '  transition(action: string): void;',
      '}',
      '',
      'const transitions: Record<State, Record<string, State>> = {',
      '  idle: { FETCH: "loading" },',
      '  loading: { SUCCESS: "success", FAILURE: "error" },',
      '  success: { RESET: "idle" },',
      '  error: { RETRY: "loading", RESET: "idle" },',
      '};',
      '',
      'function createMachine(): StateMachine {',
      '  let state: State = "idle";',
      '  ',
      '  return {',
      '    get state() { return state; },',
      '    transition(action: string) {',
      '      const next = transitions[state][action];',
      '      if (next) state = next;',
      '    }',
      '  };',
      '}',
    ],
  },
  {
    language: 'python',
    title: 'Async Context Manager',
    lines: [
      'import asyncio',
      'from contextlib import asynccontextmanager',
      '',
      '@asynccontextmanager',
      'async def managed_resource(name: str):',
      '    print(f"Acquiring {name}")',
      '    resource = await create_resource(name)',
      '    try:',
      '        yield resource',
      '    finally:',
      '        print(f"Releasing {name}")',
      '        await resource.close()',
      '',
      'async def main():',
      '    async with managed_resource("database") as db:',
      '        await db.query("SELECT * FROM users")',
    ],
  },
];

export function getRandomSnippet(): CodeSnippet {
  return codeSnippets[Math.floor(Math.random() * codeSnippets.length)];
}

export function getAllLines(): string[] {
  return codeSnippets.flatMap(snippet => [...snippet.lines, '', '']);
}
